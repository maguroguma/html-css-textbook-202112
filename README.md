# HTML, CSS

[教科書では教えてくれないHTML&CSS](https://direct.gihyo.jp/view/item/000000001556)の写経。

---

## 準備

### メディアクエリ

レスポンシブで必要なもの。
スマホを基準とする場合、以下のようにして中でPC用のスタイルを書く。

@ルールの一種、という位置づけ。

```css
@media (min-width: 768px) {
  ...
}
```

### idセレクタは避ける

優先度が高すぎてメンテナンス性が落ちてしまう。

CSSは基本的に上から読み込まれ、重複するセレクタは後から上書きされるが、
優先度が高いとそうはならない場合がある。

セレクタの指針は以下の2点。

- より多くの要素に適用されるスタイルを上の方に、特定の要素にだけ適用されるスタイルを下の方に書く
- セレクタの優先順位はできるだけ低く保つ（詳細度をあげる必要がないならあげない）

### ボックスモデル

インラインボックスとブロックボックス。

前者は `strong, span, input, img` など。
テキストの中に紛れ込むことが出来る。

後者は `div, p, h1, ul` など。
**「親要素の幅いっぱい」の大きさで作られ、「ブロックボックスの横に別のブロックボックスが並ぶこともない」。**

インラインもブロックも、どちらもボックスモデル、すなわち「マージン、ボーダー、パディング、コンテンツ」
からなるモデルの枠組みの中にある。
しかしながら、インラインに関してはコンテンツ以外はunsetだと思っておけば良い、気がする。
たいてい、何らかのブロックボックスの要素の子孫として管理する気がするし、考えても意味がない気がする。

borderのCSS書式くらいは頭に入れておきたいかも。

```css
border: 太さ＋単位 線の形状 線の色
```

#### コンテンツボックスとボーダーボックス

コンテンツボックスは、高さと幅をコンテンツ領域のみで定義する。

ボーダーボックスは、ボーダーを含めた部分までで定義する。
つまり、パディングやその先のコンテンツも含める。

**レスポンシブデザインに対応させようとすると、すべての要素のボックスモデルをボーダーボックスにする**
そうなので、ボーダーボックスをデフォルトだと思ってしまって良さそう。

```css
html *,
::before,
::after {
    box-sizing: border-box;
}
```

#### インラインボックスのボックスモデル

インラインボックスは、以下の4つが無効になる。  
**width, height, margin-top, margin-bottomの4つは無効。**

### ビューポート

レスポンシブのもとでは以下でほぼ確定。

```html
<meta name="viewport" content="width-device-width, initial-scale=1">
```

### rem文字単位

ルートエムのことで、html要素に設定されているフォントサイズを1remとする単位。
実数を係数として利用する。

### レスポンシブデザインについて

縦はあまり気にしなくてよい。

横については、ブロックボックスの幅を指定をしなければ勝手に親要素いっぱいに広がってくれる。
特に、bodyタグもブロックボックスなので、勝手にビューポートの幅に広がってくれる。

よって、無闇矢鱈に横幅を指定しないことが大事。

伸縮だけで対応しきれない場合に、メディアクエリを利用する。

一般的には「タブレットを縦に持った時」を境目として、 **「画面幅が768px」** でブレイクポイントとする。  
これを起点として、大きい画面では1200から1300px、小さい画面では320px以下、などでブレイクポイント切っていくとよい。

#### レスポンシブな画像

以下の2点を意識して、グローバルにCSSを設定してしまう。

- 画像を伸縮させて、常に親要素に収まるようにする
- ただし、実際の画像のサイズより拡大しないようにする

大きめの画像を用意しておくのがよい。

```css
img {
  max-width: 100%;
  height: auto;
  vertical-align: bottom;
}
```

※画像下のスペースを防止する嬉しさは、正直あまり良くわかっていない。

---

## 実践

### コンテナを作るHTMLタグの構成

以下のような二重構造を基本とする。

```html
<header class="page-header">
  <div class="header-container">
    ...
  </div>
</header>
```

**二重にすることで、CSSを書き換えるだけで多くのデザイン、レイアウトに対応できる柔軟なHTMLを作ることが出来るため。**

子要素の方にcontainerというクラス名を使うことに注意。
親要素の方は `header, footer, main, article, section, nav, div` など好きに選べる。

※柔軟な例かはわからないが、親側では背景画像を指定して、子側では横幅・横パディングを柔軟に設定する、などを行っていた。
二重ではなく1つのブロック要素だけだと、こういうのは確かに面倒かもしれない。
まずは、思考停止して二重構造をひとまとめに運用してみるのがいいかもしれない。

**横幅は `max-width` で決めておくと、レスポンシブを維持できる。**

### displayプロパティ

これは要暗記項目な気がする。

- block
- inline
- inline-block: 要素自体はインラインボックスで表示するが、要素内のコンテンツはブロックボックスで表示する。これにより、コンテンツの途中で改行せず、上下マージンが使えるようになる。
- none: 要素を表示しない
- flow-root: 子要素でフロートが使われたとき、そのフロートを解除する。
- flex: 子要素をフレックスボックスモードで表示する
- grid: 子要素をグリッドレイアウトモードで表示する

### 空間の作り方

パディングとマージンどっちでもいいっぽいが、最近のコンポーネント指向で考えるとパディングで考えたほうがいい気がする。
が、まだ正解はわからない。

### グループ化モジュール

コンテナより小さい単位であるモジュールも、コンテナと同様ブロックボックスをかませてグループ化するのがいいらしい。  
グループ化しておいて、親要素で幅を指定しておけば、子要素に配置する見出し、画像、テキストなどは勝手に幅が揃うから、というのが理由。  
確かに。

**親となるコンテナの最大幅を覚えておけば `max-width` によって横幅を定義しても良い。**

### 最初の要素だけ上マージンを0にしたい

子セレクタと全称セレクタの併用によって、以下のようにして実現できる。

```css
.post-contents > *:first-child {
  margin-top: 0;
}
```

### Webフォントの利用の検討

ブラウザ間の差異をなくしたいときには検討したい。

### floatについて

**floatは今は「テキストを回り込ませたいときだけ」使う。**  
昔は複雑なレイアウトを組むときに使っていた気がするけど、そうでないならばほとんど使う機会はないのかも。

使うときは親要素でflow-rootをつけて、子要素で回り込まれる対象としたいものだけに `float: left;` などのようにつけてやれば良い。

### アイコンフォントはFont Awesomeだけとりあえず覚えておく

とりあえずはこれだけ押さえておく。

### マージンとパディングの使い分けのポイント

以下の理由から **「項目と項目の間にスペースを開けるときはマージンを使う」。**

- 背景で塗りつぶすとき、パディングも含めて塗りつぶされる
- aタグのクリック可能領域には、パディングも含まれる

### フレックスボックスで横並びのデザインを作る

親要素で `display: flex;` を指定すると、子要素がフレックスボックスのルールで配置される（デフォルトは横並び）。

以下は覚えておきたい概念。

- ベース幅: 子要素の、自身のコンテンツが収まる幅のこと
- 子要素は何がなんでも横一列に並ぼうとする
- 子要素は縮小するが、伸長はしない
  - ベース幅は、要素が少なければ基本的に縮小にあたる、はず
  - 縮小しきれなくても横に並び、はみ出す場合もある
- 横一列に並ぶ要素の高さが揃う

このようなデフォルトの基本ルールがありつつ、設定によって縦に並べたり幅をコントロールしたり出来る。

**設定は、親・子要素の `flex-` プロパティで行う。**

#### flexプロパティ

flexプロパティは、子要素に対して指定する。

`flex 伸長比 縮小比 ベース幅` のように指定する、、がまずはイディオムを覚えたほうが良さそう。

- `flex: 0 0 Xpx`: 親要素の幅にかかわらず、子要素の幅が指定した幅の値で固定される
- `flex: 1 1 auto;` 親要素幅に合わせてボックスが伸縮する
  - 固定幅のボックスと並べると、auto側が幅に合わせて変動してくれるイメージになる。
- `flex: 0 1 auto`: デフォルト。

#### flex-directionプロパティ

flex-directionプロパティは、親要素側に指定する（つまり `display: flex;` と併記する形になる）。

`row, column, row-reverse, column-reverse` がある。
デフォルトは `row` 。

#### flexの解除は `display: block` で行う

親要素の話。
レスポンシブでフレックスボックスを解除したいときは、メディアクエリで明示的に `display: block` と指定する必要がある。

#### justify-contentとalign-itemsプロパティ

親要素の話。
前者はx軸、後者はy軸の配置位置の設定に関するもの。

justify-contentの値は以下5通り。

- `flex-start`: ボックスが左揃えでは位置される（デフォルト）。
- `center`: 中央揃え
- `flex-end`: 右揃え
- `space-around`: 均等間隔、両端についてはそれ以外の間隔の2分の1が割り当てられる
- `space-between`: 均等間隔、最初のボックスは左端に、最後のボックスは右端にくっつけるようにする

align-itemsの値は以下の3通り。

- `flex-start`: 親要素の上端に整列
- `center`: 親要素の中央に整列
- `flex-end`: 親要素の下端に整列

### インラインボックスという概念

例えば `h2` 要素などに `display: inline-block` とすると、以下の特徴をもったブロックボックスが作れる。

- コンテンツが収まるピッタリの幅になる
- 上下にマージンを設定できる
- widthプロパティで幅を指定できる

### ナビゲーションのパターン

`nav, ul, li, a` を使う形で、タグはほぼパターン化される。

```html
<nav>
  <ul>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
    <li><a href=""></a></li>
    ...
  </ul>
</nav>
```

さらに、ulのデフォルトCSSはリセットする。

```css
margin: 0;
padding: 0;
list-style: none;
```

**a要素もブロックにして高さ・クリック領域を確保する。**

※このあたりの、インライン要素をブロックボックス化すると何が起きるのかがよくわかっていない気がする。
基本的には、親要素が一緒に膨らんでくれる、と思っておけば良い？

### `!important`

`display: flex !important;` のようにすると、必ずそのプロパティが有効になる。

ただし、メンテナンス性の悪化につながるので、乱用は避ける。

### （上下）マージンの畳み込み、相殺

**2つの要素に設定した上下マージンが隣接するとき、どちらか大きい方のマージンが採用される、というルールのこと。**

※左右では発生しない。

例えば、それぞれ上下 `1em` のマージンが設定されているp要素が兄弟で並ぶときに、足し合わされて `2em` になるのではなく、
`1em` が採用される。
これは、割と素直な挙動とも言える。

また、親要素のマージンと子要素のマージンが隣接しているとき、子要素のマージンのほうが大きいと、畳み込みが発生して、
親要素を突き破るようなちょっと不思議な結果になる。
ただし、親要素にパディングなどがあると、マージンが隣接せずに畳み込みは発生しない。

さらに、フロート、フレックスボックス、グリッドレイアウトなどが効いている場合も、畳み込みは発生しない、っぽい。

### ポジション機能

これも毎回忘れる。。

`position: relative;` とか `position: absolute` とかいうアレ。
「画像の上に画像を重ねる」というユースケースで理解する。

※これについては書籍の説明が少ないので、MDNも併せて読む。

既定値は `static` 。

`relative` も `top, left` がそれぞれ `0px` とされていたら `static` と同じになる（多分）。
`top, left` に値を設定すると、 `static` で配置されるべき場所を基準として、指定した数値分移動されることになる。

`absolute` は、（多分）直近の祖先要素の位置を基準に配置される。
よって、その前に配置されているものの上に重ねられることとなる。

### 子要素の上下左右中央揃え

テキストコンテンツなどを上下左右中央揃えをレスポンシブに常に行おうとすると、意外と難しい。
が、今は2行だけで簡単にできる。

```css
display: grid;
place-items: center;
```

※グリッドレイアウトの特殊なイディオムだと思っておく。

### グリッドレイアウト

カードレイアウトなどはグリッドレイアウトで作る。

とりあえず概形を頭に入れておくのがいいかも。

HTMLは親ブロックの中にグリッド配置される子要素が複数ある。

```html
<div class="home-latest">
  <div class="latest-item"></div>
  <div class="latest-item"></div>
  <div class="latest-item"></div>
  <div class="latest-item"></div>
  <div class="latest-item"></div>
  <div class="latest-item"></div>
</div>
```

CSSはこんな感じ。

```css
.home-latest {
    margin: 0 0 60px 0;
    display: grid; /* 親要素にgridを指定 */
    grid-template-columns: 1fr 1fr;
    grid-auto-rows: minmax(100px, auto);
    column-gap: 10px;
    row-gap: 30px;
}
@media (min-width: 768px) {
    .home-latest {
        grid-template-columns: 1fr 1fr 1fr;
        column-gap: 20px;
    }
}
/* カード型レイアウトの中身 */
.latest-item {
    border: 1px solid #d8d8d8;
    background: #fff;
}
@media (min-width: 768px) {
    .latest-item {
        border: none;
        background: none;
    }
}
```

#### グリッドレイアウトの考え方

グリッドレイアウトは、「ある要素の表示領域をグリッド（マス目）状に区切り、そのマス目に沿って子要素のボックスを配置する」というもの。
グリッド登場以前はHTML/CSSにはなかった新しい考え方で、グラフィックデザインの手法をベースに開発されたもの（らしい）。

ある要素に `display: grid;` を適用すると、その要素のボックスに、見えないガイド線、すなわち**グリッド線**が引かれる。
グリッド線によって分割されたそれぞれの領域をグリッドと呼ぶ。
また、横方向に分割する列グリッドと、縦方向に分割する行グリッドがある。
グリッドとグリッドの間を**ギャップ**と呼ぶ。

グリッドには、左上から行を埋めていく形で子要素が割り当てられていく。

#### 最低限の3つの設定

1. 親要素の表示モードをグリッドに切り替える
2. 列グリッドテンプレートを作成する
3. 列ギャップ、行ギャップを設定する

1については、親要素で `display: grid;` を適用するだけなので、特に難しいところはない。
2, 3をスムーズにデキるようになっておきたい。

##### 列グリッドテンプレートの作成

グリッドテンプレートは、「表示領域を何分割するか、1つのマス目をどんな幅や高さにするかを決める、グリッドの基本設定」となるもの。
列だけでなく行もあるが、子要素の数が増えると自動で開業されることも考えると、列グリッドテンプレートんほうが大事になりがち。

幅については、以下のように設定する。

```css
grid-template-columns: 1fr 1fr 1fr
```

左から1列目、2列目、3列目の幅を指定している。
`1fr` というのは、全部の列の合計値を分母とした分子を示すもので、この場合はすべての列を3分の1としている。
割合として計算してくれるので便利。
`px` による固定値も使える。

行の高さについては、「最小の高さを100pxとし、あとはコンテンツが収まる高さ」としたい場合は、以下のようにすれば良い。

```css
grid-auto-rows: minmax(100px, auto);
```

##### 列ギャップ、行ギャップの設定

列方向、つまり左右の要素との隙間は `column-gap` で、
行方向、つまり上下の要素との隙間は `row-gap` で、両方共px値を指定する。

#### グリッドレイアウトの要素の整列

上下行揃えは `align-items` で、左右列揃えは `justify-items` で、それぞれのキーワードを指定することで設定できる。

- stretch: 高さや幅がグリッドのものに揃う、初期値
- start: 上端もしくは左端揃え
- center: 上下もしくは左右中央揃え
- end: 下端もしくは右端揃え

`align-items, justify-items` は `display: grid;` を設定した親要素に対して付与するもの、すなわち、
子要素全てに影響するが、グリッド単位で設定したいときは子要素に `align-self, justify-self` をつける。

#### グリッドの併合など複雑な設定

複雑なグリッドレイアウトを行うには、グリッド線について正しく理解する必要がある。

##### グリッド線

列グリッド線、行グリッド線にはそれぞれ左から、上から1-basedな番号が振られると考える。

複数の列や行にまたがる子要素を作りたいときは、このグリッド線の番号を使う。

##### `grid-column, grid-row`

例えば、**子要素に対して** `grid-column: 1/3` のように `開始番号/終了番号` という形で指定すると、
その子要素の1番目から3番目の列グリッド線で囲まれた部分が併合される。

※ちょっと複雑なので、あとは必要になったら調べる、ぐらいでいいかもしれない。

#### グリッドレイアウトとフレックスボックスの使い分け方法

以下の判断基準を覚えておく。

- ボックスを横一列に並べるときはフレックスボックス、複数行に並べたいときはグリッドレイアウト
- ボックスのサイズをガッチリ決めたいならグリッドレイアウト、サイズ自体は柔軟に対応したいならフレックスボックス

また、それぞれで実装しやすいレイアウトパターンというのもある。

- フレックスボックスで組みやすいパターン
  - ナビゲーションメニュー
  - バナー画像など小さなパーツを横一列に並べる
  - 個々のボックスのサイズは決めないが、横には並べたいレイアウト
- グリッドレイアウトで組みやすいパターン
  - カード型レイアウト
  - 縦横にボックスが複雑に入り組んだレイアウト
  - カラムレイアウト
- どちらでも良いパターン
  - メディアオブジェクトと、それに類するデザイン

### メディアオブジェクト

「写真とテキストが並ぶ」ものをメディアオブジェクトと総称するっぽい。
レイアウトに対する名前？かはよくわからない。

フレックスボックスかグリッドレイアウトいずれでも実装が可能。

※グリッドで作る例としては、例えば以下のように、リストの各項目をグリッドレイアウトにして、
1行2列のグリッドを項目とする、という手法もある。

```html
<ul>
  <!-- liに対して display: grid; -->
  <li>
    <div><img src="" alt=""></div>
    <div><a href=""></a></div>
  </li>
  <li>
    <div><img src="" alt=""></div>
    <div><a href=""></a></div>
  </li>
</ul>
```

### 説明リスト要素（ `dl,dt,dd` ）を使ってテーブル形のレイアウトを作る

`dl` 要素は説明リスト要素と呼ばれる。

以下のように `dl` 要素を親として `dt` で見出しを `dd` で内容を、という感じに続いていく。

```html
<dl>
  <dt>見出し1</dt>
  <dd>説明1</dd>
  <dt>見出し2</dt>
  <dd>説明2</dd>
  ...
</dl>
```

これに対してスタイルを当てたり、フレックスボックスにしたりすると、いい感じのテーブル型リストが作れる。

※テーブルレイアウトを作ろうと思うと `table, tr, th, td` などで作るのが自然だが、
見出しと説明の2列だけならば、説明リストのほうがずっとシンプルらしい。

### 2カラムレイアウトとその作り方

はてなブログとかでよくある、左メインコンテンツ、右他の記事のリスト、みたいなレイアウト。
昔はフロートやフレックスボックスで作っていたっぽいが、今ならグリッドレイアウトを使うのが最良とのこと。

要素の組み方は、一通りではないだろうけど例えば以下のような例がある。

```html
<div class="page-main">
  <div class="main-container">
    <!-- columnsクラスのブロックに display: grid; -->
    <div class="columns">
      <main class="columns-post">
        ...
      </main>
      <aside class="columns-side">
        ...
      </aside>
    </div>
  </div>
</div>
```

CSSはPC向けのメディアクエリで以下のように設定する。

```css
/* 2カラムレイアウトのコントロール */
@media (min-width: 768px) {
    .columns {
        display: grid;
        grid-template-columns: 1fr 290px; /* 片方のカラム幅を固定にすることも出来る */
        grid-gap: 40px;
    }
}
```

### フォームが含まれるページ

SPAで実際にform要素が使われることは無いのかもしれないが、
レイアウトの組み方は土台として知っておくべきのような気はする。

#### 概形

form要素を親として、その中で各入力項目が並べられる。

この `p > label, input` というのは公式みたいなものなので、そのまま覚えてしまう。

```html
<form id="form" class="form" action="#">
    <p>
        <label for="question1">お名前<span class="required">必須</span></label><br>
        <input type="text" name="question1" id="question1" placeholder="お名前" required>
    </p>
    <p>
        <label for="question2">メールアドレス<span class="required">必須</span></label><br>
        <input type="email" name="question2" id="question2" placeholder="mail@example.com" required>
    </p>
    <p>
        <label for="present">希望のプレゼント</label>
        <span class="required">必須</span><br>
        <select id="present" name="present">
            <option>プレゼントを選んでください</option>
            <option value="1" required>ステンレスマグ</option>
            <option value="2">Tシャツ</option>
            <option value="3">トートバッグ</option>
        </select>
    </p>
    <p>
        <label for="question3">メッセージ</label><br>
        <textarea id="question3" name="question3"></textarea>
    </p>
    <p>
      <!-- チェックボックスはlabelですべて囲んでしまったほうが良い -->
        <label><input id="privacy" type="checkbox" name="privacy" value="privacy" required>プライバシーポリシーに同意する</label>
    </p>
    <p class="form-button"><input type="submit" name="send" value="キャンペーンに応募する"></p>
</form>
```

---

### 覚えておきたいプロパティ

- line-hight: 1行の高さ、単位は不要。
- text-align: テキストの行揃え。left, right, center, justify（両端揃え）
- border: ボックスのボーダーライン、指定の仕方を頭に入れておきたい。
  - `border: 太さ 形状 色`
    - e.g.: `border: 4px solid #b8e5ea`

